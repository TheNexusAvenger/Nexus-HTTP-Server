{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nexus HTTP Server Nexus HTTP Server is a light-weight .NET HTTP server implementation loosely based on concepts of setting up a server in the Java Spark Microframework . While not fully featured like Java Spark or Spring Boot, the goal is to provide a very simple class library for abstracting handling HTTP requests from clients. This was originally implemneted in Nexus Git, but was removed from the codebase for use in other applications. .NET Compatibility The class library targets .NET Standard 2.0. For creating applications, .NET Framework v4.6.1 or .NET Core 2.0 or newer is required. Check compatibility for other versions of .NET if you are going to use it with something else (like Mono or Xaramin).","title":"Home"},{"location":"#nexus-http-server","text":"Nexus HTTP Server is a light-weight .NET HTTP server implementation loosely based on concepts of setting up a server in the Java Spark Microframework . While not fully featured like Java Spark or Spring Boot, the goal is to provide a very simple class library for abstracting handling HTTP requests from clients. This was originally implemneted in Nexus Git, but was removed from the codebase for use in other applications.","title":"Nexus HTTP Server"},{"location":"#net-compatibility","text":"The class library targets .NET Standard 2.0. For creating applications, .NET Framework v4.6.1 or .NET Core 2.0 or newer is required. Check compatibility for other versions of .NET if you are going to use it with something else (like Mono or Xaramin).","title":".NET Compatibility"},{"location":"getting-started/split-requests/","text":"Warning Split requests should not be used for public-facing applications. No protections are provided that would result in out-of-memory errors from malicious requests. Split requests intended to be used for cases where a lot of data needs to be transferred via POST requests, and this amount of data may be beyond what the client can send or recieve, like Roblox Studio. Protocol The protocol is able to have split requests and split responses. For this example, a client is only able to send 6 characters in the body and the server is configured to only send back 4 characters. The POST body sent is then echoed back without modification. Standalone If no split-request parameters are speicifed, the request is treated as non-split and the response is sent back complete. POST http : // localhost : 8080 \"Test1 Test2 Test3\" HTTP 200 \"Test1 Test2 Test3\" This implementation allows for clients without needing to get around limits to not need to use the implementation, such as external end-to-end testing of applications. Sending Split Requests Split requests take data as URL arguments, which include the following: - maxPackets - The total packets that will be sent - requestId - The id of the packet to send (not sent in the first request) - packet - The id of the pakcet to send, starting at 0 (optional in the first request) When a request is incomplete (not all packets sent), a JSON string is returned with the following - status - \"incomplete\" - id - The value to use in requestId to continue the request When a response is complete, the following is returned: - status - \"success\" - id - The value to use in responseId for getting responses - currentPacket - The id of the packet, starting at 0. - maxPackets - The total packets to recieve - packet - The data in the pakcet For getting additional responses (maxPackets > 1), the following arguments can be used: - getResponse = true - Specifies that responses are being fetched - responseId - The response id to read from - packet - The packet id to get from the response, starting at 0 For the example above, the requests would look like the following: POST http : // localhost : 8080 ? maxPackets = 3 \"Test1 \" HTTP 200 \"{\" status \\ \":\\\" incomplete \\ \",\\\" id \\ \":0}\" POST http : // localhost : 8080 ? maxPackets = 3 & packet = 1 & requestId = 0 \"Test2 \" HTTP 200 \"{\" status \\ \":\\\" incomplete \\ \",\\\" id \\ \":0}\" POST http : // localhost : 8080 ? maxPackets = 3 & packet = 2 & requestId = 0 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":0,\\\" maxPackets \\ \":4 \\\" packet \\ \":\\\" Test1 \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 1 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":1,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" Tes \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 2 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":2,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" t2 T \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 3 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":3,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" est3 \\ \"}\" After a response is fully retrieved, it is removed to save memory. This however does cause a vulnerability since malicous (or just incorrect usage of the protocol) will result in a memory leak. Same goes for sending requests since they need to be stored and combined. Additionally, there is no checks for the size, so denial of service attacks can be performed by sending large, incomplete requests that won't get cleared. This system is not intended for publicly facing applications. Code Example The code from the previous example can be tweaked to work with this (ignoring the limit of sending back 4 characters) by using the base class SplitClientRequestHandler for the client handler and using SplitRequestHandler which ensures that the GET handlers are added. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; using Nexus.Http.Server.SplitHttp.Request ; namespace Demo { public class Program { public class Handler : SplitClientRequestHandler { /* * Returns a response for a given complete request. */ public override HttpResponse GetCompleteResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( request . GetBody ()); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new SplitRequestHandler (); handler . RegisterHandler ( \"POST\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"POST\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } }","title":"Split Requests"},{"location":"getting-started/split-requests/#protocol","text":"The protocol is able to have split requests and split responses. For this example, a client is only able to send 6 characters in the body and the server is configured to only send back 4 characters. The POST body sent is then echoed back without modification.","title":"Protocol"},{"location":"getting-started/split-requests/#standalone","text":"If no split-request parameters are speicifed, the request is treated as non-split and the response is sent back complete. POST http : // localhost : 8080 \"Test1 Test2 Test3\" HTTP 200 \"Test1 Test2 Test3\" This implementation allows for clients without needing to get around limits to not need to use the implementation, such as external end-to-end testing of applications.","title":"Standalone"},{"location":"getting-started/split-requests/#sending-split-requests","text":"Split requests take data as URL arguments, which include the following: - maxPackets - The total packets that will be sent - requestId - The id of the packet to send (not sent in the first request) - packet - The id of the pakcet to send, starting at 0 (optional in the first request) When a request is incomplete (not all packets sent), a JSON string is returned with the following - status - \"incomplete\" - id - The value to use in requestId to continue the request When a response is complete, the following is returned: - status - \"success\" - id - The value to use in responseId for getting responses - currentPacket - The id of the packet, starting at 0. - maxPackets - The total packets to recieve - packet - The data in the pakcet For getting additional responses (maxPackets > 1), the following arguments can be used: - getResponse = true - Specifies that responses are being fetched - responseId - The response id to read from - packet - The packet id to get from the response, starting at 0 For the example above, the requests would look like the following: POST http : // localhost : 8080 ? maxPackets = 3 \"Test1 \" HTTP 200 \"{\" status \\ \":\\\" incomplete \\ \",\\\" id \\ \":0}\" POST http : // localhost : 8080 ? maxPackets = 3 & packet = 1 & requestId = 0 \"Test2 \" HTTP 200 \"{\" status \\ \":\\\" incomplete \\ \",\\\" id \\ \":0}\" POST http : // localhost : 8080 ? maxPackets = 3 & packet = 2 & requestId = 0 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":0,\\\" maxPackets \\ \":4 \\\" packet \\ \":\\\" Test1 \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 1 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":1,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" Tes \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 2 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":2,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" t2 T \\ \"}\" GET http : // localhost : 8080 ? getResponse = true & responseId = 0 & packet = 3 \"Test 3\" HTTP 200 \"{\" status \\ \":\\\" success \\ \",\\\" id \\ \":0,\\\" currentPacket \\ \":3,\\\" maxPackets \\ \":4,\\\" packet \\ \":\\\" est3 \\ \"}\" After a response is fully retrieved, it is removed to save memory. This however does cause a vulnerability since malicous (or just incorrect usage of the protocol) will result in a memory leak. Same goes for sending requests since they need to be stored and combined. Additionally, there is no checks for the size, so denial of service attacks can be performed by sending large, incomplete requests that won't get cleared. This system is not intended for publicly facing applications.","title":"Sending Split Requests"},{"location":"getting-started/split-requests/#code-example","text":"The code from the previous example can be tweaked to work with this (ignoring the limit of sending back 4 characters) by using the base class SplitClientRequestHandler for the client handler and using SplitRequestHandler which ensures that the GET handlers are added. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; using Nexus.Http.Server.SplitHttp.Request ; namespace Demo { public class Program { public class Handler : SplitClientRequestHandler { /* * Returns a response for a given complete request. */ public override HttpResponse GetCompleteResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( request . GetBody ()); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new SplitRequestHandler (); handler . RegisterHandler ( \"POST\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"POST\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } }","title":"Code Example"},{"location":"getting-started/standard-server/","text":"Standard Server Nexus HTTP Server attempts to abstract handling HTTP requests from clients to returning requests for specific URLs, and handling requests with the context of the parameters and the body. Creating the Server The system is set up to have a RequestHandler object be given to an HttpServer object. Other IClientRequestHandler objects are registered to the RequestHandler . The reason there is a seprate request hanlder is to allow for easier testing without having to create a server instance. Optionally, multiple server objects can be used to listen on different ports if needed. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } If you run the code above and open up a browser and go to http://localhost:8080 , you will see the message \"Invalid request\". Adding Client Request Handlers While the code above works, it isn't useful since it doesn't handle any requests. To make it useful, it has to be set up to handle requests. To add a handler, you need to provide tthe following: - The HTTP method ( GET , POST , PATCH , etc) - The relative URL - The handler that implements IClientRequestHandler using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return new HttpResponse ( 200 , \"text/html\" , \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } The code above adds registers for http://localhost:8080 and http://localhost:8080/test and returns a \"Hello world!\" message. Since text responses are common, HttpResponse.CreateSuccessResponse can be used for the example above. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } URL Parameters URL parameters can also be parsed from the request. The HttpRequest class passed into the GetResponseData method contains a URL object and the body of the request ( \"\" if not present, like in GET requests). using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } Using the http://localhost:8080 and http://localhost:8080/test URLs in a browser will show the same results, but using http://localhost:8080?param=Test%20param and http://localhost:8080/test?param=Test%20param will show Test param on the second line. If a parameter isn't defined, null is returned.","title":"Standard Server"},{"location":"getting-started/standard-server/#standard-server","text":"Nexus HTTP Server attempts to abstract handling HTTP requests from clients to returning requests for specific URLs, and handling requests with the context of the parameters and the body.","title":"Standard Server"},{"location":"getting-started/standard-server/#creating-the-server","text":"The system is set up to have a RequestHandler object be given to an HttpServer object. Other IClientRequestHandler objects are registered to the RequestHandler . The reason there is a seprate request hanlder is to allow for easier testing without having to create a server instance. Optionally, multiple server objects can be used to listen on different ports if needed. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } If you run the code above and open up a browser and go to http://localhost:8080 , you will see the message \"Invalid request\".","title":"Creating the Server"},{"location":"getting-started/standard-server/#adding-client-request-handlers","text":"While the code above works, it isn't useful since it doesn't handle any requests. To make it useful, it has to be set up to handle requests. To add a handler, you need to provide tthe following: - The HTTP method ( GET , POST , PATCH , etc) - The relative URL - The handler that implements IClientRequestHandler using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return new HttpResponse ( 200 , \"text/html\" , \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } The code above adds registers for http://localhost:8080 and http://localhost:8080/test and returns a \"Hello world!\" message. Since text responses are common, HttpResponse.CreateSuccessResponse can be used for the example above. using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } }","title":"Adding Client Request Handlers"},{"location":"getting-started/standard-server/#url-parameters","text":"URL parameters can also be parsed from the request. The HttpRequest class passed into the GetResponseData method contains a URL object and the body of the request ( \"\" if not present, like in GET requests). using Nexus.Http.Server.Http.Request ; using Nexus.Http.Server.Http.Response ; using Nexus.Http.Server.Http.Server ; namespace Demo { public class Program { public class Handler : IClientRequestHandler { /* * Returns a response for a given request. */ public HttpResponse GetResponseData ( HttpRequest request ) { return HttpResponse . CreateSuccessResponse ( \"Hello world!\" ); } } public static void Main ( string [] args ) { // Create the request handlers. var handler = new RequestHandler (); handler . RegisterHandler ( \"GET\" , \"/\" , new Handler ()); handler . RegisterHandler ( \"GET\" , \"/test\" , new Handler ()); // Create and start the server. var server = new HttpServer ( 8080 , handler ); server . Start (); } } } Using the http://localhost:8080 and http://localhost:8080/test URLs in a browser will show the same results, but using http://localhost:8080?param=Test%20param and http://localhost:8080/test?param=Test%20param will show Test param on the second line. If a parameter isn't defined, null is returned.","title":"URL Parameters"}]}